/**
 * @file runtime_log.c
 *
 * Runtime log  implementation
 *
 * @author German Rivera
 */
#include "runtime_log.h"
#include "compile_time_checks.h"
#include "mem_utils.h"
#include "io_utils.h"
#include "atomic_utils.h"
#include "time_utils.h"
#include "cpu_reset_counter.h"
#include "stack_trace.h"
#include "arm_cortex_m_defs.h"
#include "rtos_wrapper.h"
#include "serial_console.h"
#include <stdarg.h>
#include <print_scan.h>

/*
 * Sizes (in bytes) of the runtime log buffers
 */
#define DEBUG_LOG_BUFFER_SIZE     (2 * UINT32_C(1024))
#define ERROR_LOG_BUFFER_SIZE     (1 * UINT32_C(1024))
#define INFO_LOG_BUFFER_SIZE      (1 * UINT32_C(1024))

/**
 * Max number of stack trace entries to be captured for
 * a runtime log entry.
 */
#define RUNTIME_LOG_MAX_STACK_TRACE_ENTRIES    8

/**
 * A runtime log
 */
struct runtime_log {
    /**
     * Buffer where the most recent output generated by runtime_log_printf()
     * is stored
     */
    char *buffer_p;

    /**
     * Buffe size in bytes
     */
    uint16_t buffer_size;

    /**
     * Logging flags
     */
    uint16_t flags;
#   define PRINT_STACK_TRACE    BIT(0)

    /**
     * Next position to fill in buffer
     */
    uint16_t cursor;

    /**
     * Sequence number for next message to store in buffer
     */
    uint16_t seq_num;

    /**
     * Number of times the log buffer has wrapped around.
     */
    uint32_t wrap_count;

    /**
     * Mutex to serialize writes to the log
     */
    struct rtos_mutex mutex;
};

/**
 * All runtime logs
 *
 * NOTE: This is not a regular C global variable, as it is not
 * in the '.data' section nor in  the '.bss' section (see linker script).
 */
static struct {
    /*
     * Runtime log buffers
     */
    char debug_log_buffer[DEBUG_LOG_BUFFER_SIZE];
    char error_log_buffer[ERROR_LOG_BUFFER_SIZE];
    char info_log_buffer[INFO_LOG_BUFFER_SIZE];

    /**
     * Array of runtime logs:
     */
    struct runtime_log logs[NUM_RUNTIME_LOGS];
} g_runtime_logs __attribute__ ((section(".runtime_logs")));


static void runtime_log_init(struct runtime_log *runtime_log_p,
                             char *buffer_p,
                             uint_fast16_t buffer_size,
                             uint_fast16_t flags,
                             uint32_t cpu_reset_count)
{
    if (cpu_reset_count == 0) {
        runtime_log_p->buffer_p = buffer_p;
        runtime_log_p->buffer_size = buffer_size;
        runtime_log_p->flags = flags;
        runtime_log_p->cursor = 0;
        runtime_log_p->seq_num = 0;
        runtime_log_p->wrap_count = 0;
    }

    rtos_mutex_init(&runtime_log_p->mutex, "runtime log mutex");
}


/**
 * Initializes the runtime logs, if the CPU reset count is 0.
 */
void init_runtime_logs(void)
{
    static const struct {
        char *buffer_p;
        uint16_t buffer_size;
        uint16_t flags;
    } logs_config[] = {
        [RUNTIME_DEBUG_LOG] = {
            .buffer_p = g_runtime_logs.debug_log_buffer,
            .buffer_size = sizeof(g_runtime_logs.debug_log_buffer),
            .flags = PRINT_STACK_TRACE,
        },

        [RUNTIME_ERROR_LOG] = {
            .buffer_p = g_runtime_logs.error_log_buffer,
            .buffer_size = sizeof(g_runtime_logs.error_log_buffer),
            .flags = PRINT_STACK_TRACE,
        },

        [RUNTIME_INFO_LOG] = {
            .buffer_p = g_runtime_logs.info_log_buffer,
            .buffer_size = sizeof(g_runtime_logs.info_log_buffer),
            .flags = 0x0,
        },
    };

    C_ASSERT(ARRAY_SIZE(logs_config) == NUM_RUNTIME_LOGS);

    uint32_t cpu_reset_count = read_cpu_reset_counter();

    for (uint_fast8_t i = 0; i < NUM_RUNTIME_LOGS; i ++) {
        runtime_log_init(&g_runtime_logs.logs[i],
                         logs_config[i].buffer_p,
                         logs_config[i].buffer_size,
                         logs_config[i].flags,
                         cpu_reset_count);

        runtime_log_printf(i, "Microcontroller booted (reset count: %u)\n",
                           cpu_reset_count);
    }

    D_ASSERT(CALLER_IS_RESET_HANDLER());
}


/**
 * Callback function invoked from the KSDK _doprint() function
 */
static int runtime_log_putchar(int c, void *putchar_arg_p)
{
    struct runtime_log *runtime_log_p = putchar_arg_p;
    uint_fast16_t cursor = runtime_log_p->cursor;

    runtime_log_p->buffer_p[cursor] = c;
    cursor ++;
    if (cursor == runtime_log_p->buffer_size) {
        cursor = 0;
        runtime_log_p->wrap_count ++;
    }

    runtime_log_p->cursor = cursor;
    return 0;
}


/**
 * Prints a 32-bit unsigned integer in decimal
 */
static void runtime_log_print_uint32_decimal(struct runtime_log *runtime_log_p,
                                             uint32_t value)
{
    char buffer[11];
    char *s = &buffer[sizeof(buffer) - 1];

    *s = '\0';
    do {
        s--;
        *s = (value % 10) + '0';
        value /= 10;
    } while (value > 0);

    while (*s != '\0') {
        runtime_log_putchar(*s, runtime_log_p);
        s ++;
    }
}


/**
 * Prints a 32-bit unsigned integer in hexadecimal
 */
static void runtime_log_print_uint32_hexdecimal(
                struct runtime_log *runtime_log_p,
                uint32_t value)
{
    char buffer[9];
    uint_fast8_t  hex_digit;
    char *s = &buffer[sizeof(buffer) - 1];

    runtime_log_putchar('0', runtime_log_p);
    runtime_log_putchar('x', runtime_log_p);
    *s = '\0';
    do {
        s--;
        hex_digit = (value & 0xf);
        if (hex_digit < 0xa) {
            *s = hex_digit + '0';
        } else {
            *s = (hex_digit - 0xa) + 'a';
        }

        value >>= 4;
    } while (value > 0);

    while (*s != '\0') {
        runtime_log_putchar(*s, runtime_log_p);
        s ++;
    }
}


static void runtime_log_print_stack_trace(struct runtime_log *runtime_log_p,
                                          uint_fast8_t num_entries_to_skip)
{
    uintptr_t trace_buff[RUNTIME_LOG_MAX_STACK_TRACE_ENTRIES];
    uint_fast8_t num_trace_entries = sizeof(trace_buff) / sizeof(trace_buff[0]);

    stack_trace_capture(num_entries_to_skip,
                        trace_buff,
                        &num_trace_entries);

    for (uint_fast8_t i = 0; i < num_trace_entries; i ++) {
        runtime_log_putchar('\t', runtime_log_p);
        runtime_log_print_uint32_hexdecimal(runtime_log_p, trace_buff[i]);
        runtime_log_putchar('\n', runtime_log_p);
    }
}


static void runtime_log_vprintf(struct runtime_log *runtime_log_p,
                                const char *fmt,
                                va_list va)
{
    bool use_mutex;
    uint32_t int_mask;

    if (CPU_INTERRUPTS_ARE_DISABLED() || CPU_MODE_IS_HANDLER()) {
        use_mutex = false;
        int_mask = disable_cpu_interrupts();
    } else  {
        use_mutex = true;
        rtos_mutex_lock(&runtime_log_p->mutex);
    }

    runtime_log_print_uint32_decimal(runtime_log_p, runtime_log_p->seq_num);
    runtime_log_putchar(':', runtime_log_p);

    runtime_log_print_uint32_decimal(runtime_log_p, rtos_get_ticks_since_boot());
    runtime_log_putchar(':', runtime_log_p);

    runtime_log_print_uint32_decimal(runtime_log_p, get_cpu_clock_cycles());
    runtime_log_putchar(':', runtime_log_p);

    struct rtos_task *task_p = rtos_task_self();

    runtime_log_print_uint32_hexdecimal(runtime_log_p, (uintptr_t)task_p);
    runtime_log_putchar(':', runtime_log_p);

    (void)_doprint(runtime_log_p, runtime_log_putchar, -1, (char *)fmt, va);

    if (runtime_log_p->flags & PRINT_STACK_TRACE) {
        runtime_log_print_stack_trace(runtime_log_p, 3);
    }

    runtime_log_p->seq_num ++;
    if (use_mutex) {
        rtos_mutex_unlock(&runtime_log_p->mutex);
    } else {
        restore_cpu_interrupts(int_mask);
    }
}


/**
 * printf that writes messages to the runtime log buffer
 *
 * @param log               index of the log to be written
 * @param fmt               format string
 * @param ...               variable arguments
 *
 * @return None
 */
void runtime_log_printf(enum runtime_logs log, const char *fmt, ...)
{
    va_list  va;

    va_start(va, fmt);
    runtime_log_vprintf(&g_runtime_logs.logs[log], (char *)fmt, va);
    va_end(va);
}


/**
 * Dumps the contents of the given runtime log buffer to the serial console
 *
 * @param log    index of the log to be dumped
 */
void runtime_log_dump(enum runtime_logs log)
{
    static const char *const log_names[] = {
        [RUNTIME_DEBUG_LOG] = "Debug",
        [RUNTIME_ERROR_LOG] = "Error",
        [RUNTIME_INFO_LOG] = "Info",
    };

    if (log >= NUM_RUNTIME_LOGS) {
        console_printf("Invalid runtime log index: %d\n", log);
        return;
    }

    struct runtime_log *runtime_log_p = &g_runtime_logs.logs[log];
    char *end_p;

    console_printf("%s log (wrap count: %u):\n"
                   "(sequence number:ticks since boot:CPU cycles:task pointer:message)\n",
                   log_names[log], runtime_log_p->wrap_count);

    if (runtime_log_p->wrap_count == 0) {
        end_p = runtime_log_p->buffer_p + runtime_log_p->cursor;
    } else {
        end_p = runtime_log_p->buffer_p + runtime_log_p->buffer_size;
    }

    for (char *p = runtime_log_p->buffer_p; p != end_p; p ++) {
        console_putchar(*p);
    }

    console_putchar('\n');
}
